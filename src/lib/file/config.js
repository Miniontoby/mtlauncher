import {BaseDirectory, readTextFile, writeTextFile} from '@tauri-apps/api/fs';
import { fileBackedStore } from '$lib/preferences';
import { get } from 'svelte/store';

const KV_REGEX = /\s*(?<key>[a-z_]+)\s?=\s?(?<val>.*)/;

export const CONFIG_NODES = {
    'Screen': {
        'fullscreen': {
            description: 'Whether or not the game window is fullscreen',
            type: 'bool'
        },
        'screen_w': {
            description: 'The width of the game window, ignored when fullscreen = true',
            type: 'int',
            min: 1,
            max: 65535,
        },
        'screen_h': {
            description: 'The height of the game window, ignored when fullscreen = true',
            type: 'int',
            min: 1,
            max: 65535,
        },
        'pause_on_lost_focus': {
            description: 'Whether or not to pause the game when another window is active.',
            type: 'bool'
        },
        'fps_max': {
            description: 'Limit of FPS (frames per second)',
            type: 'int',
            min: 1,
            max: 360
        },
        'vsync': {
            description: 'Vertical screen synchronisation',
            type: 'bool'
        }
    },
    'Controls': {
        'mouse_sensitivity': {
            description: 'The sensitivity of your mouse. Higher = faster mouse movements',
            type: 'float',
            min: 0.1,
            max: 10,
            step: 0.1,
            range: true
        },
        'invert_mouse': {
            description: 'Invert vertical mouse movement',
            type: 'bool'
        }
    }
};

let configCache = false;
export async function getConfig() {
    if (!configCache) {
        configCache = await fileBackedStore('minetest.mtlauncher.conf', {}, (content) => parseConfigFile(content), (content) => writeConfigFile(content));
    }

    return configCache;
}

// file backed store funcs
export function parseConfigFile(data) {
    let res = {};

    let configSections = Object.keys(CONFIG_NODES);

    let lines = data.split(/\r?\n/);
    for (const line of lines) {
        const parsed = KV_REGEX.exec(line);
        if (parsed !== null) {
            const { groups: { key, val }} = parsed;
            for (const section of configSections) {
                if (CONFIG_NODES[section].hasOwnProperty(key)) {
                    res[key] = parseField(key, val);
                }
            }
        }
    }

    return res;
}

function parseField(key, value) {
    let sections = Object.keys(CONFIG_NODES);
    for (const section of sections) {
        if (CONFIG_NODES[section].hasOwnProperty(key)) {
            let type = CONFIG_NODES[section][key].type;
            switch (type) {
                case 'string':
                default:
                    return value;

                case 'bool':
                    return (value === 'true');

                case 'float':
                    return parseFloat(value);

                case 'int':
                    return parseInt(value);
            }
        }
    }
    return value;
}

export function writeConfigFile(data) {
    let keys = Object.keys(data);
    let res = `# mtlauncher general config\n# this gets copied as a "merged" config when launching a game version\n# if you edit this file manually, restart mtlauncher!\n\n`;
    if (!keys.length) return res;

    for (const key of keys) {
        res += `${key} = ${String(data[key])}\n`;
    }
    return res;
}

export async function writeMergedConfig(version) {
    let res = `# this file is autogenerated by mtlauncher. edit "minetest.mtlauncher.conf" or "versions/${version}/minetest.conf" instead of this!\n`;
    try {
        res += await readTextFile(`versions/${version}/minetest.conf`, {
            dir: BaseDirectory.App
        });
    }
    catch {
        // no version specific config
        console.log(`No version specific config for ${version} found...`);
    }

    res += `\n${writeConfigFile(get(configCache))}`;
    try {
        await writeTextFile('minetest.merged.conf', res, {
            dir: BaseDirectory.App
        });
        return true;
    }
    catch (e) {
        console.log(e);
        // failed for some reason...
        return false;
    }
}